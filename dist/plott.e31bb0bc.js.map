{"version":3,"sources":["node_modules/regenerator-runtime/runtime.js","src/PlotterArea.js","src/Serial.js","src/Plotter.js","index.js"],"names":["PlotterArea","serial","waitSetting","settings","maxAccX","maxAccY","xAcc","yAcc","maxY","settingsKeys","Object","keys","settingsCallback","line","forEach","settingsKey","reg","RegExp","match","exec","console","log","onMessage","Serial","bSupported","navigator","started","sending","queue","onMessageCallbacks","error","baudRate","bufferSize","requestPort","port","open","dataBits","decoder","TextDecoderStream","readable","pipeTo","writable","reader","getReader","encoder","TextEncoderStream","writer","getWriter","listen","data","warn","i","len","length","push","dequeue","shift","write","then","whileRead","read","value","done","split","trim","callback","whileReadable","requestAnimationFrame","releaseLock","index","indexOf","splice","PEN_DOWN","PEN_UP","Plotter","Z_UP","Z_DOWN","plotterArea","penStatus","init","home","penUp","x","y","velocity","penDown","plotter","initted","input","document","querySelector","addEventListener","e","keyCode","window","preventDefault","getElementById","setTimeout","draw","scene","Urpflanze","Scene","width","height","lines","Line","repetitions","sideLength","distance","vertexCallback","vertex","vertexRepetition","propArguments","context","noise","offset","repetition","row","time","add","subdivide","calculateRect","minX","maxX","minY","moveTo","currentTime","sceneChilds","getChildren","generate","childBuffer","getBuffer","childIndexedBuffer","getIndexedBuffer","currentBufferIndex","vertexIndex","currentIndexing","frameLength","lineTo","Number","MIN_VALUE","MAX_VALUE"],"mappings":";AAAA;AIAA,AJCA;AACA;AIAA,AJCA;AACA;AACA;AACA,AGNA;AHOA;AACA,AGPA;AHQA;AACA;AINA,AJOA,IIPMsF,OAAO,GAAG,IAAIZ,gBAAJ,EAAhB;AACA,AJOA,IIPIa,OAAO,GAAG,KAAd;AJQA;AACA,ICdMvF,KGOS+E;AJQf,ACdC,uBAAY9E,MAAZ,EAAoB;ADerB,ACfqB,ICDfsB;AFiBN,AEhBC,oBAAc;AFiBf,AChBE,ACDa,SDCRtB,MAAL,GAAcA,MAAd;ADiBF,AChBE,SAAKC,WAAL,8CGIF;AAAA,AJaA,AChBE,ACFA,SAAKsB,UAAL,GAAkB,YAAYC,SAA9B;AEKF,AJcA,AElBE,SAAKC,OAAL,GAAe,KAAf;AEIF,AJeA,AGnBA,ADEE,ICFI8C,KDEC7C,GCFO,GAAG,CDEf,GAAe,KAAf,CCFF;ACIA,AJgBA,AGnBA,ADEE,ICFI8C,KDEC7C,CCFK,GAAG,CDEb,GAAa,EAAb,ECFF;ACGA,AJiBA,AEjBE,SAAKC,kBAAL,GAA0B,EAA1B,EDDa;AGCf,AJkBA,AClBE,IEDI6C,MFCEvE,OGCHoF,CHDW,MGAhB;AAAA,AJmBA,AGnBC,AFCEnF,ACCD,QDDCA,ACCG,CAAC,KAAKoB,CDDF,EAAE,EEDCrB,CFAG,ICEd,EAAsB,CCFvB,EAAsB;ACAvB,AJoBA,AGpBuB,AFEpBE,ACCAe,MAAAA,EDDAf,KCCO,CAACyB,CDDD,EAAE,ECCT,CDHa,ACGC,0BAAd;AEHH,AJqBA,AClBGxB,ACCA,KAFD,GDCCA,GCCM,CDDF,EAAE,GAHO;ADsBhB,AGrBE,AFGCC,ACCAa,MAAAA,EDDAb,CEHIJ,GFGA,CCCG,CDDD,ACCEkB,GCJT,AFDc,ACKb,CAAY,ECJG,oBDIf;AELH,AJuBA,AGrBGsD,AFGAnE,ACCA,MCJAmE,EFGAnE,EEHI,EAAE,AFGF,EEJW,AFIT;ADmBT,AGrBGoE,AFHa,ACOd,MCJCA,MAAM,EAAE,GFGF,GANO,CAAd;AGAF,AJyBA,AGxBkB,KAAhB;ACEDW,AJuBD,AGpBE,AFEA,SEFKtF,CFECQ,EGLP8E,GDGC,GAAc,CCHR,GAAG,ADGShE,AFEA,GAAGb,CGLtB,KHK4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AAD,CAAJ,GAAU,MAA1B;AEqBF,AJmCD,AEvDG,2BCOK+B,GAAGC,GAAG;ACcb,AJmCD,AGhDE,UAAI,KAAKL,SAAL,KAAmBL,MAAvB,EAA+B,KAAKQ,KAAL;ACchC,AJmCD,AGhDE,ADPA,UAAI,CCOChF,ADPA,KAAK0B,CCOV,CAAY8B,KAAZ,ADPA,EAAmB,UCOGyB,CAAtB,eAA4BC,CAA5B;ACcD,AJmCD,AGhDE,ADPC,WCOIF,EDPC1B,GCON,IDPC;AEqBF,AJmCD,AGhDE,ADPC;AEsBF,AJkCD,AEvDE;AEuBD,AJiCD;AIhCC,AJiCD,2BGjDQ2B,GAAGC,GAAoB;ACiB9B,AJiCD,AGlD+B,UAAjBC,QAAiB,YDNpB,2DCMc,IAAM;AHmD/B,AGlDE,ADPS,UCOL,KAAKN,SAAL,KAAmBN,QAAvB,EAAiC,KAAKa,OAAL;ACkBlCY,AJiCD,AGjDE,WAAKhG,CCgBNgG,KDhBC,CAAYxC,ICgBH,CAAC,ADhBV,eAAyByB,CAAzB,eAA+BC,CAA/B,eAAqCC,QAArC;ACgBU,AJkCZ,AGjDE,ADTA,UAAI,KAAKlD,IAAL,EEwBYgE,EFxBC,EEwBG,CAACZ,EFxBC1D,KEwBF,AFxBH,CEwBP,AFxBkByB,MAAX,GAAoB,CAArC,EAAwC;AEwB9B,AJmCZ,AE1DG,YAAMJ,CEuBE,EAAsB,CFvBpB,GEuBF,AFvBK,CEuBf,IFvBoBrB,KAAL,CAAW4B,KAAX,EAAb;AF2DH,AE1DGpC,QAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwB4B,IAAxB;AEhDH,AJ2GA,AE1DG,aAAKtB,OAAL,GAAe,IAAf;AEjDH,AJ4GA,AE1DG,aAAKmB,MAAL,CAAYW,KAAZ,CAAkBR,IAAlB,EAAwBS,IAAxB,CAA6B,YAAM;AElDtC,AJ6GA,AE1DI,UAAA,KAAI,CAAC/B,OAAL,GAAe,KAAf;AEnDJ,AJ8GA,AE1DI,SAFD,MCQY+C;AC1Df,AJ+GA,AE1DG;AErDH,AJgHA,AE1DE;AEtDF,AJiHA;AACA;AACA,6BE3DU;AF4DV,AE5DU;AEiBV,AJ4CA,SI5CSwB,IAAT,CAAcZ,OAAd,EAAuB;AACtB,AJ4CD,AE7DE,MEiBKa,IFjBD,CEi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CAA6BW,QAA7B;AEqFAyD,AJ0BF,AE9GE,IEoFAA,IAAI,EAAJA,IADM;AAENC,AJ0BF,II1BEA,IAAI,EAAJA,IAFM;AAGNC,AJ0BF,II1BEA,IAAI,EAAJA,IAHM;AAINpH,AJ0BF,II1BEA,IAAI,EAAJA,qBFrFUyD,UAAU;AEiFd,AJ+BR,AE/GE,GEgFD,OFhFOI,KAAK,GAAG,KAAKxC,kBAAL,CAAwByC,OAAxB,CAAgCL,QAAhC,CAAd;AEsFD,AJ0BD;AACA,AEhHE,UAAII,KAAK,IAAI,CAAb,EAAgB;AEuFlBoB,AJ0BA,AEhHG,QEsFK,CAACE,IFtFD9D,YEsFR,CAA0B,KFtFvB,CAAwB0C,CEsF3B,EAAmC,GFtFhC,CAA+BF,KAA/B,EAAsC,CAAtC;AEsFgC,AJ2BnC,AEhHG,SEqFsCU,IAAI,EAAV;AAAA,AJ4BnC,AEhHE,CEoFF;AJ6BA;AACA;AACA;AACA;AACA;AACA,eEnHexD;AFoHf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"plott.e31bb0bc.js","sourceRoot":"..","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","class PlotterArea {\r\n\tconstructor(serial) {\r\n\t\tthis.serial = serial\r\n\t\tthis.waitSetting()\r\n\t}\r\n\r\n\twaitSetting() {\r\n\t\tconst settings = {\r\n\t\t\tmaxAccX: 110,\r\n\t\t\tmaxAccY: 111,\r\n\t\t\txAcc: 120,\r\n\t\t\tyAcc: 121,\r\n\t\t\tmaxY: 130,\r\n\t\t\tmaxY: 131,\r\n\t\t}\r\n\t\tconst settingsKeys = Object.keys(settings)\r\n\r\n\t\tconst settingsCallback = line => {\r\n\t\t\tsettingsKeys.forEach(settingsKey => {\r\n\t\t\t\tconst reg = new RegExp(`^\\$${settings[settingsKey]}=(\\d*\\.?\\d*)`, 'ig')\r\n\t\t\t\tconst match = reg.exec(line)\r\n\t\t\t\tconsole.log(line, match)\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis.serial.onMessage(settingsCallback)\r\n\t}\r\n}\r\n\r\nexport default PlotterArea\r\n","class Serial {\r\n\tconstructor() {\r\n\t\tthis.bSupported = 'serial' in navigator\r\n\t\tthis.started = false\r\n\r\n\t\tthis.sending = false\r\n\t\tthis.queue = []\r\n\t\tthis.onMessageCallbacks = []\r\n\r\n\t\tif (!this.bSupported) {\r\n\t\t\tconsole.error('Serial API non supported')\r\n\t\t} else {\r\n\t\t\tconsole.log('Serial API supported')\r\n\t\t}\r\n\t}\r\n\r\n\tasync init(baudRate, bufferSize = 2048) {\r\n\t\tif (this.bSupported) {\r\n\t\t\tthis.port = await navigator.serial.requestPort()\r\n\t\t\tawait this.port.open({ baudRate: baudRate, bufferSize, dataBits: 8 })\r\n\r\n\t\t\tconst decoder = new TextDecoderStream()\r\n\t\t\tthis.port.readable.pipeTo(decoder.writable)\r\n\t\t\tthis.reader = decoder.readable.getReader()\r\n\r\n\t\t\tconst encoder = new TextEncoderStream()\r\n\t\t\tencoder.readable.pipeTo(this.port.writable)\r\n\t\t\tthis.writer = encoder.writable.getWriter()\r\n\r\n\t\t\tthis.started = true\r\n\r\n\t\t\tthis.listen()\r\n\t\t}\r\n\t}\r\n\r\n\twrite(data) {\r\n\t\tif (!this.port) {\r\n\t\t\tconsole.warn(`Cannot write \"${data}\". Port not open`)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tdata = typeof data === 'string' ? [data] : data\r\n\r\n\t\tfor (let i = 0, len = data.length; i < len; i++) {\r\n\t\t\tthis.queue.push(data[i] + '\\r\\n')\r\n\t\t}\r\n\r\n\t\tif (!this.sending) {\r\n\t\t\tthis.dequeue()\r\n\t\t}\r\n\t}\r\n\r\n\tdequeue() {\r\n\t\tif (this.port && this.queue.length > 0) {\r\n\t\t\tconst data = this.queue.shift()\r\n\t\t\tconsole.log('dequeue2', data)\r\n\t\t\tthis.sending = true\r\n\t\t\tthis.writer.write(data).then(() => {\r\n\t\t\t\tthis.sending = false\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tlisten() {\r\n\t\tif (!this.port) {\r\n\t\t\tconsole.warn('port not open')\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst whileRead = async () => {\r\n\t\t\ttry {\r\n\t\t\t\tconst { value, done } = await this.reader.read()\r\n\t\t\t\tif (done) return false\r\n\t\t\t\tif (value && value.length) {\r\n\t\t\t\t\tvalue.split('\\r\\n').forEach(line => {\r\n\t\t\t\t\t\tline = line.trim()\r\n\t\t\t\t\t\tif (line && line.length > 0) {\r\n\t\t\t\t\t\t\tthis.onMessageCallbacks.forEach(callback => callback(line))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tthis.dequeue()\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tconsole.log('error', error)\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst whileReadable = () => {\r\n\t\t\tif (this.port.readable) {\r\n\t\t\t\tif (whileRead()) {\r\n\t\t\t\t\treturn requestAnimationFrame(whileReadable)\r\n\t\t\t\t}\r\n\t\t\t\tthis.reader.releaseLock()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trequestAnimationFrame(whileReadable)\r\n\t}\r\n\r\n\tonMessage(callback) {\r\n\t\tthis.onMessageCallbacks.push(callback)\r\n\t}\r\n\r\n\toffMessage(callback) {\r\n\t\tconst index = this.onMessageCallbacks.indexOf(callback)\r\n\t\tif (index >= 0) {\r\n\t\t\tthis.onMessageCallbacks.splice(index, 1)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default Serial\r\n","import PlotterArea from './PlotterArea'\r\nimport Serial from './Serial'\r\n\r\nconst PEN_DOWN = 'PEN_DOWN'\r\nconst PEN_UP = 'PEN_UP'\r\n\r\nclass Plotter {\r\n\tconstructor(settings) {\r\n\t\tthis.settings = {\r\n\t\t\tZ_UP: 30,\r\n\t\t\tZ_DOWN: 0,\r\n\t\t}\r\n\r\n\t\tthis.serial = new Serial()\r\n\t\tthis.plotterArea = new PlotterArea(this.serial)\r\n\t\tthis.penStatus = PEN_UP\r\n\t}\r\n\r\n\tasync init() {\r\n\t\tawait this.serial.init(115200)\r\n\r\n\t\tthis.home()\r\n\t}\r\n\r\n\tuseRelativePosition() {\r\n\t\tthis.serial.write('G91')\r\n\t}\r\n\r\n\tuseAbsolutePosition() {\r\n\t\tthis.serial.write('G90')\r\n\t}\r\n\r\n\thome() {\r\n\t\tif (this.penStatus !== PEN_UP) this.penUp()\r\n\r\n\t\tthis.serial.write('G28')\r\n\t}\r\n\r\n\tpenUp() {\r\n\t\tif (this.penStatus !== PEN_UP) {\r\n\t\t\tthis.penStatus = PEN_UP\r\n\t\t\tthis.serial.write(`M3 S${this.settings.Z_UP}`)\r\n\t\t}\r\n\t}\r\n\r\n\tpenDown() {\r\n\t\tif (this.penStatus !== PEN_DOWN) {\r\n\t\t\tthis.penStatus = PEN_DOWN\r\n\t\t\tthis.serial.write(`M3 S${this.settings.Z_DOWN}`)\r\n\t\t}\r\n\t}\r\n\r\n\tmoveTo(x, y) {\r\n\t\tif (this.penStatus !== PEN_UP) this.penUp()\r\n\t\tthis.serial.write(`X${x} Y${y}`)\r\n\t\tthis.penUp()\r\n\t}\r\n\r\n\tlineTo(x, y, velocity = 1000) {\r\n\t\tif (this.penStatus !== PEN_DOWN) this.penDown()\r\n\r\n\t\tthis.serial.write(`G1 X${x} Y${y} F${velocity}`)\r\n\t}\r\n}\r\n\r\nexport default Plotter\r\n","import 'regenerator-runtime/runtime'\r\n\r\nimport Plotter from './src/Plotter'\r\n\r\nconst plotter = new Plotter()\r\nlet initted = false\r\n\r\nasync function init() {\r\n\tif (initted) return\r\n\r\n\tinitted = true\r\n\r\n\tawait plotter.init()\r\n\r\n\t// const result = document.querySelector('#result')\r\n\t// let i = 1\r\n\t// plotter.serial.onMessage(line => {\r\n\t// \tline = line\r\n\t// \t\t.replace(/&/g, '&amp;')\r\n\t// \t\t.replace(/</g, '&lt;')\r\n\t// \t\t.replace(/>/g, '&gt;')\r\n\t// \t\t.replace(/\"/g, '&quot;')\r\n\t// \t\t.replace(/'/g, '&#039;')\r\n\t// \tresult.innerHTML = `<li><small>${++i}</small> ${line}</li>` + result.innerHTML\r\n\t// })\r\n\r\n\tconst input = document.querySelector('#input')\r\n\tinput.addEventListener('keydown', async e => {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tplotter.serial.write(input.value)\r\n\t\t\tinput.value = ''\r\n\t\t}\r\n\t})\r\n\r\n\twindow.addEventListener('beforeunload', e => {\r\n\t\te.preventDefault()\r\n\t\tplotter.home()\r\n\t})\r\n\twindow.addEventListener('unload', e => {\r\n\t\te.preventDefault()\r\n\t\tplotter.home()\r\n\t})\r\n\r\n\tdocument.getElementById('penup').addEventListener('click', () => {\r\n\t\tplotter.penUp()\r\n\t})\r\n\tdocument.getElementById('pendown').addEventListener('click', () => {\r\n\t\tplotter.penDown()\r\n\t})\r\n\tdocument.getElementById('home').addEventListener('click', () => {\r\n\t\tplotter.home()\r\n\t})\r\n\r\n\t// const rect = document.getElementById('rect')\r\n\t// const context = rect.getContext('2d')\r\n\t// rect.width = 200\r\n\t// rect.height = 200\r\n\t// rect.style.width = '200px'\r\n\t// rect.style.height = '200px'\r\n\t// rect.style.background = 'red'\r\n\t// rect.style.position = 'fixed'\r\n\t// rect.style.top = '20px'\r\n\t// rect.style.right = '20px'\r\n\t// const box = rect.getBoundingClientRect()\r\n\r\n\t// context.fillStyle = '#eee'\r\n\t// context.fillRect(0, 0, 200, 200)\r\n\t// rect.addEventListener('mousemove', e => {\r\n\t// \tconst x = e.clientX - box.x\r\n\t// \tconst y = e.clientY - box.y\r\n\r\n\t// \tplotter.lineTo(x / 5, y / 5)\r\n\r\n\t// \tcontext.fillStyle = '#000'\r\n\t// \tcontext.fillRect(x, y, 1, 1)\r\n\t// })\r\n\r\n\tsetTimeout(() => draw(plotter), 2000)\r\n}\r\n\r\nfunction draw(plotter) {\r\n\tconst scene = new Urpflanze.Scene({\r\n\t\twidth: 110,\r\n\t\theight: 190,\r\n\t})\r\n\r\n\tconst lines = new Urpflanze.Line({\r\n\t\trepetitions: [60, 1],\r\n\t\tsideLength: () => 50, // Add a function for dynamic generation\r\n\t\tdistance: [1, 0],\r\n\t\tvertexCallback: (vertex, vertexRepetition, propArguments) => {\r\n\t\t\tconst y = propArguments.context.noise(\r\n\t\t\t\t'seed',\r\n\t\t\t\tvertexRepetition.offset * 4,\r\n\t\t\t\tpropArguments.repetition.row.offset * 3,\r\n\t\t\t\tpropArguments.time / 1000\r\n\t\t\t)\r\n\r\n\t\t\tvertex[1] += y * 10\r\n\t\t},\r\n\t})\r\n\r\n\tscene.add(lines)\r\n\r\n\t// Subdivide lines for add points\r\n\tlines.subdivide(6)\r\n\r\n\tconst { minX, maxX, minY, maxY } = calculateRect(scene)\r\n\r\n\tplotter.moveTo(minX, minY)\r\n\tplotter.moveTo(maxX, minY, 5000)\r\n\tplotter.moveTo(maxX, maxY, 5000)\r\n\tplotter.moveTo(minX, maxY, 5000)\r\n\tplotter.moveTo(minX, minY, 5000)\r\n\r\n\tscene.currentTime = 0\r\n\tconst sceneChilds = scene.getChildren()\r\n\r\n\tfor (let i = 0, len = sceneChilds.length; i < len; i++) {\r\n\t\tsceneChilds[i].generate(0, true)\r\n\r\n\t\tconst childBuffer = sceneChilds[i].getBuffer()\r\n\t\tconst childIndexedBuffer = sceneChilds[i].getIndexedBuffer()\r\n\r\n\t\tfor (\r\n\t\t\tlet currentBufferIndex = 0, vertexIndex = 0, len = childIndexedBuffer.length;\r\n\t\t\tcurrentBufferIndex < len;\r\n\t\t\tcurrentBufferIndex++\r\n\t\t) {\r\n\t\t\tconst currentIndexing = childIndexedBuffer[i]\r\n\r\n\t\t\tplotter.moveTo(childBuffer[vertexIndex], childBuffer[vertexIndex + 1])\r\n\r\n\t\t\tvertexIndex += 2\r\n\t\t\tfor (let len = vertexIndex + currentIndexing.frameLength - 2; vertexIndex < len; vertexIndex += 2) {\r\n\t\t\t\t// console.log('asdas', childBuffer[vertexIndex], childBuffer[vertexIndex + 1])\r\n\t\t\t\tplotter.lineTo(childBuffer[vertexIndex], childBuffer[vertexIndex + 1], 5000)\r\n\t\t\t}\r\n\r\n\t\t\t// if (currentIndexing.shape.isClosed())\r\n\t\t\t// plotter.lineTo(childBuffer[vertexIndex], childBuffer[vertexIndex + 1])\r\n\t\t}\r\n\t}\r\n\r\n\tplotter.home()\r\n}\r\n\r\nfunction calculateRect(scene) {\r\n\tlet maxX = Number.MIN_VALUE\r\n\tlet minX = Number.MAX_VALUE\r\n\tlet maxY = Number.MIN_VALUE\r\n\tlet minY = Number.MAX_VALUE\r\n\r\n\tconst sceneChilds = scene.getChildren()\r\n\r\n\tfor (let i = 0, len = sceneChilds.length; i < len; i++) {\r\n\t\tsceneChilds[i].generate(0, true)\r\n\r\n\t\tconst childBuffer = sceneChilds[i].getBuffer()\r\n\t\tconst childIndexedBuffer = sceneChilds[i].getIndexedBuffer()\r\n\r\n\t\tfor (\r\n\t\t\tlet currentBufferIndex = 0, vertexIndex = 0, len = childIndexedBuffer.length;\r\n\t\t\tcurrentBufferIndex < len;\r\n\t\t\tcurrentBufferIndex++\r\n\t\t) {\r\n\t\t\tconst currentIndexing = childIndexedBuffer[i]\r\n\r\n\t\t\tif (minX > childBuffer[vertexIndex]) minX = childBuffer[vertexIndex]\r\n\t\t\tif (maxX < childBuffer[vertexIndex]) maxX = childBuffer[vertexIndex]\r\n\t\t\tif (minY > childBuffer[vertexIndex + 1]) minY = childBuffer[vertexIndex + 1]\r\n\t\t\tif (maxY < childBuffer[vertexIndex + 1]) maxY = childBuffer[vertexIndex + 1]\r\n\r\n\t\t\tvertexIndex += 2\r\n\t\t\tfor (let len = vertexIndex + currentIndexing.frameLength - 2; vertexIndex < len; vertexIndex += 2) {\r\n\t\t\t\tif (minX > childBuffer[vertexIndex]) minX = childBuffer[vertexIndex]\r\n\t\t\t\tif (maxX < childBuffer[vertexIndex]) maxX = childBuffer[vertexIndex]\r\n\t\t\t\tif (minY > childBuffer[vertexIndex + 1]) minY = childBuffer[vertexIndex + 1]\r\n\t\t\t\tif (maxY < childBuffer[vertexIndex + 1]) maxY = childBuffer[vertexIndex + 1]\r\n\t\t\t}\r\n\r\n\t\t\t// if (currentIndexing.shape.isClosed())\r\n\t\t\t// plotter.lineTo(childBuffer[vertexIndex], childBuffer[vertexIndex + 1])\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tminX,\r\n\t\tmaxX,\r\n\t\tminY,\r\n\t\tmaxY,\r\n\t}\r\n}\r\n\r\ndocument.addEventListener('click', () => init())\r\n"]}